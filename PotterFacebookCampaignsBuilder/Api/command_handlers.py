import typing
from copy import deepcopy

from facebook_business.adobjects.ad import Ad
from facebook_business.adobjects.adaccount import AdAccount
from facebook_business.adobjects.adset import AdSet
from facebook_business.adobjects.campaign import Campaign

from Core.Tools.Logger.LoggerMessageBase import LoggerMessageBase, LoggerMessageTypeEnum
from Core.Tools.RabbitMQ.RabbitMqClient import RabbitMqClient
from Core.Web.FacebookGraphAPI.GraphAPI.GraphAPISdkBase import GraphAPISdkBase
from Core.Web.FacebookGraphAPI.GraphAPI.HTTPRequestBase import HTTPRequestBase
from PotterFacebookCampaignsBuilder.Api import commands
from PotterFacebookCampaignsBuilder.Api.Startup import rabbit_logger, startup
from PotterFacebookCampaignsBuilder.Infrastructure.GraphAPIHandlers.GraphAPIAdBuilderHandler import (
    GraphAPIAdBuilderHandler,
)
from PotterFacebookCampaignsBuilder.Infrastructure.GraphAPIHandlers.GraphAPIAdPreviewBuilderHandler import (
    GraphAPIAdPreviewBuilderHandler,
)
from PotterFacebookCampaignsBuilder.Infrastructure.GraphAPIHandlers.GraphAPIAdSetBuilderHandler import (
    GraphAPIAdSetBuilderHandler,
)
from PotterFacebookCampaignsBuilder.Infrastructure.GraphAPIHandlers.GraphAPICampaignBuilderHandler import (
    GraphAPICampaignBuilderHandler,
)
from PotterFacebookCampaignsBuilder.Infrastructure.GraphAPIRequests.GraphAPIRequestAudienceSize import (
    GraphAPIRequestAudienceSize,
)
from PotterFacebookCampaignsBuilder.Infrastructure.IntegrationEvents.CampaignCreatedEvent import CampaignCreatedEvent
from PotterFacebookCampaignsBuilder.Infrastructure.IntegrationEvents.CampaignCreatedEventMapping import (
    CampaignCreatedEventMapping,
)


class AdPreview:
    @classmethod
    def handle(
        cls,
        command: commands.AdPreview = None,
        facebook_config: typing.Any = None,
        permanent_token: typing.AnyStr = None,
    ) -> typing.AnyStr:
        ad_builder = GraphAPIAdPreviewBuilderHandler(facebook_config=facebook_config, permanent_token=permanent_token)
        ad_builder.build_ad_creative(
            account_id=command.account_id,
            ad_template=command.ad_template,
            page_facebook_id=command.page_facebook_id,
            instagram_facebook_id=command.instagram_facebook_id,
        )
        params = {"ad_format": command.ad_format, "creative": ad_builder.ad_creative_details}
        ad_account = AdAccount(fbid=command.account_id)
        ad_preview = ad_account.get_generate_previews(params=params)

        if ad_preview:
            return ad_preview[0].export_all_data()["body"].replace('scrolling="yes"', 'scrolling="no"')

        return None


class AudienceSize:
    @classmethod
    def handle(
        cls,
        permanent_token: typing.AnyStr = None,
        account_id: typing.AnyStr = None,
        audience_details: typing.AnyStr = None,
    ):
        try:
            audience_size_request = GraphAPIRequestAudienceSize(
                access_token=permanent_token, account_id=account_id, audience_details=audience_details
            )
            response, _ = HTTPRequestBase.get(audience_size_request.url)
        except Exception as e:
            raise e

        if isinstance(response, Exception):
            raise response

        audience_size_estimate = response[0].get("estimate_mau", None)
        return audience_size_estimate


class PublishCampaign:
    @classmethod
    def handle(
        cls,
        request: typing.Dict = None,
        business_owner_id: typing.AnyStr = None,
        facebook_config: typing.Any = None,
        permanent_token: str = None,
    ) -> typing.List[typing.Dict]:

        GraphAPISdkBase(business_owner_permanent_token=permanent_token, facebook_config=facebook_config)

        campaign_structure = request["campaign_optimization_details"]["campaign_structure"]
        campaign_template = request["campaign_template"]

        ad_set_template = request["ad_set_template"]
        ad_set_budget_template = request["campaign_optimization_details"]["budget_template"]

        ad_template = request["advert_template"]

        # Check if automated structure is required
        if campaign_structure["use_recommended_campaign_structure"]:
            campaign_structure["split_by_device"] = True
            campaign_structure["split_by_location"] = True
            campaign_structure["split_by_gender"] = True
            campaign_structure["split_by_age_range"] = False

        # Build campaigns
        campaign_builder = GraphAPICampaignBuilderHandler()

        # If 'geo_locations' or 'countries' are not set at ad set level, set them to [None]
        ad_set_template = cls._set_default_location_targeting(ad_set_template)

        # Build all campaigns generated by the split
        campaign_builder.build_campaigns(
            campaign_structure,
            campaign_template,
            ad_set_template["targeting"]["device_platforms"],
            ad_set_template["targeting"]["geo_locations"]["countries"],
        )

        # Build adsets
        ad_set_builder = GraphAPIAdSetBuilderHandler()
        if (
            "campaign_budget_optimization" in campaign_template.keys()
            and campaign_template["campaign_budget_optimization"]
        ):
            is_using_campaign_budget_optimization = True
        else:
            is_using_campaign_budget_optimization = False
        ad_set_builder.build_ad_sets_full(
            campaign_structure, ad_set_template, ad_set_budget_template, is_using_campaign_budget_optimization
        )

        # Build adverts
        ad_builder = GraphAPIAdBuilderHandler()

        # Publish on Facebook
        campaign_tree = []
        campaign_response = {"facebook_id": None, "ad_sets": []}

        ad_account = AdAccount(fbid=request["ad_account_id"])
        for campaign_index, campaign in enumerate(campaign_builder.campaigns):
            try:
                # Publish campaign
                facebook_campaign = ad_account.create_campaign(params=campaign)
                campaign_facebook_id = facebook_campaign.get_id()

                # Add new campaign to response
                campaign_tree.append(deepcopy(campaign_response))
                campaign_tree[campaign_index]["facebook_id"] = campaign_facebook_id

                for ad_set_index, ad_set in enumerate(ad_set_builder.ad_sets):
                    ad_set["campaign_id"] = campaign_facebook_id
                    # remove array of [None] from countries
                    if (
                        "geo_locations" in ad_set["targeting"].keys()
                        and "countries" in ad_set["targeting"]["geo_locations"]
                        and ad_set["targeting"]["geo_locations"]["countries"] == [None]
                    ):
                        del ad_set["targeting"]["geo_locations"]["countries"]
                    ad_set["debug"] = "all"
                    facebook_ad_set = ad_account.create_ad_set(params=ad_set)
                    ad_set_facebook_id = facebook_ad_set.get_id()

                    # Add new adset to response
                    ad_set_response = {"facebook_id": ad_set_facebook_id, "ads": []}
                    campaign_tree[campaign_index]["ad_sets"].append(deepcopy(ad_set_response))

                    # Publish ad
                    for ad_index, ad_template_details in enumerate(ad_template["details"]["generated_adverts"]):
                        current_ad_template = {}
                        current_ad_template.update(ad_template_details)
                        current_ad_template["ad_format"] = ad_template["ad_format"]
                        ad_builder.build_ad(
                            request["ad_account_id"],
                            ad_set_facebook_id,
                            current_ad_template,
                            ad_template["details"]["page_facebook_id"],
                            ad_template["details"]["instagram_account_facebook_id"],
                        )
                        ad_builder.ad[Ad.Field.name] = ad_set["name"] + " - Ad - " + str(ad_index + 1)
                        ad = ad_account.create_ad(params=ad_builder.ad)
                        ad_facebook_id = ad.get_id()

                        # Add new ad to response
                        campaign_tree[campaign_index]["ad_sets"][ad_set_index]["ads"].append(ad_facebook_id)
            except Exception as e:
                cls._delete_incomplete_campaigns(campaign_tree)
                raise e

        try:
            mapper = CampaignCreatedEventMapping(target=CampaignCreatedEvent)
            response = mapper.load(campaign_tree)
            response.business_owner_id = business_owner_id
            response.account_id = request["ad_account_id"]
            cls.publish_response(response)
        except Exception as e:
            raise e

        return campaign_tree

    @staticmethod
    def _set_default_location_targeting(ad_set_template):
        if "geo_locations" not in ad_set_template["targeting"].keys():
            ad_set_template["targeting"]["geo_locations"] = {"countries": [None]}

        if "countries" not in ad_set_template["targeting"]["geo_locations"].keys():
            ad_set_template["targeting"]["geo_locations"]["countries"] = [None]

        return ad_set_template

    @classmethod
    def _delete_incomplete_campaigns(cls, campaign_tree):
        for campaign in campaign_tree:
            cls.delete_campaign(campaign["facebook_id"])
            for ad_set in campaign["ad_sets"]:
                cls.delete_ad_set(ad_set["facebook_id"])
                for ad_facebook_id in ad_set["ads"]:
                    cls.delete_ad(ad_facebook_id)

    @staticmethod
    def delete_campaign(facebook_id):
        try:
            campaign = Campaign(fbid=facebook_id)
            campaign.api_delete()
        except Exception as e:
            raise e

    @staticmethod
    def delete_ad_set(facebook_id):
        try:
            ad_set = AdSet(fbid=facebook_id)
            ad_set.api_delete()
        except Exception as e:
            raise e

    @staticmethod
    def delete_ad(facebook_id):
        try:
            ad = Ad(fbid=facebook_id)
            ad.api_delete()
        except Exception as e:
            raise e

    @classmethod
    def publish_response(cls, response):
        try:
            rabbitmq_client = RabbitMqClient(
                startup.rabbitmq_config, startup.exchange_details.name, startup.exchange_details.outbound_queue.key
            )
            rabbitmq_client.publish(response)
            log = LoggerMessageBase(
                mtype=LoggerMessageTypeEnum.INTEGRATION_EVENT,
                name=response.message_type,
                extra_data={"event_body": rabbitmq_client.serialize_message(response)},
            )
            rabbit_logger.logger.info(log.to_dict())
        except Exception as e:
            raise e
